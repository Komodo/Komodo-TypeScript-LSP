{"version":3,"sources":["../../src/util.js"],"names":["Utils","text","prefix","indexOf","randint","randomint","buf","Buffer","writeUInt32BE","numberValue","toBuffer","ip","ipl","parts","split","length","i","parseInt","signedLimit","input","counter","charAt","substring","myIp","ifaces","networkInterfaces","keys","Object","loop1","iface","j","family","internal","address","obj","newObj","key","hasOwnProperty","dict","tags","value","push"],"mappings":"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","file":"util.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport xorshift from 'xorshift';\nimport Int64 from 'node-int64';\nimport os from 'os';\n\nexport default class Utils {\n    /**\n     * Determines whether a string contains a given prefix.\n     *\n     * @param {string} text - the string for to search for a prefix\n     * @param {string} prefix - the prefix to search for in the text given.\n     * @return {boolean} - boolean representing whehter or not the\n     * string contains the prefix.\n     **/\n    static startsWith(text: string, prefix: string): boolean {\n        return text.indexOf(prefix) === 0;\n    }\n\n    /**\n     * Determines whether a string contains a given prefix.\n     *\n     * @return {Buffer}  - returns a buffer representing a random 64 bit\n     * number.\n     **/\n    static getRandom64(): Buffer {\n        let randint = xorshift.randomint();\n        let buf = new Buffer(8);\n        buf.writeUInt32BE(randint[0], 0);\n        buf.writeUInt32BE(randint[1], 4);\n        return buf;\n    }\n\n    /**\n     * @param {string|number} numberValue - a string or number to be encoded\n     * as a 64 bit byte array.\n     * @return {Buffer} - returns a buffer representing the encoded string, or number.\n     **/\n    static encodeInt64(numberValue: any): any {\n        return new Int64(numberValue).toBuffer();\n    }\n\n\n    /**\n     * @param {string} ip - a string representation of an ip address.\n     * @return {number} - a 32-bit number where each byte represents an\n     * octect of an ip address.\n     **/\n    static ipToInt(ip: string): ?number {\n        let ipl = 0;\n        let parts = ip.split('.');\n        if (parts.length != 4) {\n            return null;\n        }\n\n        for (let i = 0; i < parts.length; i++) {\n            ipl <<= 8;\n            ipl += parseInt(parts[i], 10);\n        }\n\n        let signedLimit = 0x7fffffff;\n        if (ipl > signedLimit) {\n            return (1 << 32) - ipl;\n        }\n        return ipl;\n    }\n\n    /**\n     * @param {string} input - the input for which leading zeros should be removed.\n     * @return {string} - returns the input string without leading zeros.\n     **/\n    static removeLeadingZeros(input: string): string {\n        let counter = 0;\n        let length = input.length - 1;\n        for (let i = 0; i < length; i++) {\n            if(input.charAt(i) === '0') {\n                counter++;\n            } else {\n                break;\n            }\n        }\n\n        return input.substring(counter);\n    }\n\n    static myIp(): string {\n        let myIp = '0.0.0.0';\n        let ifaces = os.networkInterfaces();\n        let keys = Object.keys(ifaces);\n        loop1:\n        for (let i = 0; i < keys.length; i++) {\n            let iface = ifaces[keys[i]];\n            for (let j = 0; j < iface.length; j++) {\n                if (iface[j].family === 'IPv4' && !iface[j].internal) {\n                    myIp = iface[j].address;\n                    break loop1;\n                }\n            }\n        }\n        return myIp;\n    }\n\n    static clone(obj: any): any {\n        let newObj = {};\n        for (let key in obj) {\n            if (obj.hasOwnProperty(key)) {\n                newObj[key] = obj[key];\n            }\n        }\n\n        return newObj;\n    }\n\n    static convertObjectToTags(dict: any): Array<Tag> {\n        let tags: Array<Tag> = [];\n        for (let key in dict) {\n            let value = dict[key];\n            if (dict.hasOwnProperty(key)) {\n                tags.push({ 'key': key, 'value': value });\n            }\n        }\n\n        return tags;\n    }\n}\n"]}