{"version":3,"sources":["../../test/span.js"],"names":["constants","opentracing","thrift","describe","reporter","tracer","span","spanContext","beforeEach","logger","withBinaryIds","encodeInt64","SAMPLED_MASK","now","it","equal","context","setOperationName","operationName","initialDate","Date","getTime","_startTime","expectedDuration","finishDate","finish","_duration","spans","length","spanInfo","toString","_logger","_errorMsgs","_setSamplingPriority","isOk","isDebug","isSampled","isNotOk","keyValuePairs","numberTag","stringTag","booleanTag","addTags","count","i","_tags","key","timestamp","event","log","_logs","fields","value","payload","a","JSON","stringify","expectedTimestamp","clock","useFakeTimers","restore","spy","_baggageSetter","setBaggageItem","getBaggageItem","calledOnce","calledWith","child","startSpan","childOf","unnormalizedKey","_normalizeBaggageKey","_getBaggageHeaderCache","options","desc","sampling","reportedSpans","each","o","setTag","_sampler","deepEqual","samplingFinalized","childSpan","Tags","SAMPLING_PRIORITY","unsampledSpan","headers","inject","FORMAT_HTTP_HEADERS","unFinalizedSpan","_isWriteable","sampledSpan","hasTags","newSpan","isEqual"],"mappings":"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","file":"span.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport _ from 'lodash';\nimport {assert, expect} from 'chai';\nimport ConstSampler from '../src/samplers/const_sampler.js';\nimport ProbabilisticSampler from '../src/samplers/probabilistic_sampler';\nimport * as constants from '../src/constants.js';\nimport InMemoryReporter from '../src/reporters/in_memory_reporter.js';\nimport JaegerTestUtils from '../src/test_util';\nimport MockLogger from './lib/mock_logger';\nimport * as opentracing from 'opentracing';\nimport Span from '../src/span.js';\nimport SpanContext from '../src/span_context.js';\nimport sinon from 'sinon';\nimport * as thrift from '../src/thrift.js';\nimport Tracer from '../src/tracer.js';\nimport Utils from '../src/util.js';\n\ndescribe('span should', () => {\n    let reporter = new InMemoryReporter();\n    let tracer, span, spanContext;\n\n    beforeEach(() => {\n        tracer = new Tracer(\n            'test-service-name',\n            reporter,\n            new ConstSampler(true),\n            { logger: new MockLogger() }\n        );\n\n        spanContext = SpanContext.withBinaryIds(\n            Utils.encodeInt64(1),\n            Utils.encodeInt64(2),\n            Utils.encodeInt64(3),\n            constants.SAMPLED_MASK\n        );\n\n        span = new Span(\n            tracer,\n            'op-name',\n            spanContext,\n            tracer.now()\n        );\n    });\n\n    it('return span context when context() is called', () => {\n        assert.equal(span.context(), spanContext);\n    });\n\n    it('return tracer when tracer() is called', () => {\n        assert.equal(span.tracer(), tracer);\n    });\n\n    it('set operation name correctly', () => {\n        span.setOperationName('operation-name');\n        assert.equal(span.operationName, 'operation-name');\n    });\n\n    it('finish span with custom duration', () => {\n        let initialDate = new Date(2011, 9, 1).getTime();\n        span._startTime = initialDate;\n        let expectedDuration = 1000;\n        let finishDate = initialDate + expectedDuration;\n\n        span.finish(finishDate);\n\n        assert.equal(span._duration, expectedDuration);\n        assert.equal(reporter.spans.length, 1);\n        assert.equal(reporter.spans[0], span);\n    });\n\n    it('finish span twice logs error', () => {\n        span.finish();\n        span.finish();\n        let spanInfo = `operation=${span.operationName},context=${span.context().toString()}`;\n        assert.equal(tracer._logger._errorMsgs[0], `${spanInfo}#You can only call finish() on a span once.`);\n    });\n\n    it('set debug and sampling version through sampling priority', () => {\n        span._setSamplingPriority(3);\n\n        assert.isOk(span.context().isDebug());\n        assert.isOk(span.context().isSampled());\n    });\n\n    it('unset sampling on span', () => {\n        span._setSamplingPriority(0);\n\n        assert.isNotOk(span.context().isSampled());\n    });\n\n    it('add tags', () => {\n        let keyValuePairs = {\n            numberTag: 7,\n            stringTag: 'string',\n            booleanTag: true,\n        };\n        span.addTags(keyValuePairs);\n        span.addTags({numberTag: 8});\n\n        // test to make sure consecutive calls with same key does not\n        // overwrite the first key.\n        let count = 0;\n        for(let i = 0; i < span._tags.length; i++) {\n            if (span._tags[i].key === 'numberTag') {\n                count += 1;\n            }\n        }\n\n        assert.isOk(span._tags.length, 4);\n        assert.equal(count, 2);\n    });\n\n    it('add logs with timestamp, and event', () => {\n        let timestamp = new Date(2016, 8, 12).getTime();\n        let event = 'some messgae';\n        span.log({ 'event': event }, timestamp);\n\n        assert.equal(span._logs.length, 1);\n        assert.equal(span._logs[0].timestamp, timestamp);\n        assert.equal(span._logs[0].fields[0].value, event);\n    });\n\n    it('add logs with payload', () => {\n        let payload = {a: 1};\n        span.log({payload});\n\n        assert.equal(span._logs.length, 1);\n        assert.equal(JSON.stringify(span._logs[0].fields[0].value), JSON.stringify(payload));\n    });\n\n    it('add logs with event, but without timestamp', () => {\n        let expectedTimestamp = 123.456;\n        // mock global clock\n        let clock = sinon.useFakeTimers(expectedTimestamp);\n        let event = 'some messgae';\n        span.log({ event });\n\n        assert.equal(span._logs.length, 1);\n        assert.equal(span._logs[0].timestamp, expectedTimestamp);\n        assert.equal(span._logs[0].fields[0].value, event);\n        clock.restore();\n    });\n\n    it ('set and retrieve baggage correctly', () => {\n        let key = 'some-key';\n        let value = 'some-value';\n\n        let spy = sinon.spy(span._baggageSetter, 'setBaggage');\n        span.setBaggageItem(key, value);\n        assert.equal(value, span.getBaggageItem(key));\n        assert(spy.calledOnce);\n        assert(spy.calledWith(span, key, value));\n    });\n\n    it ('inherit baggage from parent', () => {\n        let key = 'some-key';\n        let value = 'some-value';\n\n        span.setBaggageItem(key, value);\n        let child = tracer.startSpan('child', { childOf: span.context() });\n        assert.equal(value, child.getBaggageItem(key));\n    });\n\n    it ('normalized key correctly', () => {\n        let unnormalizedKey = 'SOME_KEY';\n        let key = span._normalizeBaggageKey(unnormalizedKey);\n\n        assert.equal(key, 'some-key');\n        assert.isOk(unnormalizedKey in Span._getBaggageHeaderCache());\n    });\n\n    describe('adaptive sampling tests for span', () => {\n        let options = [\n            { desc: 'sampled: ', sampling: true, reportedSpans: 1 },\n            { desc: 'unsampled: ', sampling: false, reportedSpans: 0}\n        ];\n        _.each(options, (o) => {\n            it (o.desc + 'should save tags, and logs on an unsampled span incase it later becomes sampled', () => {\n                let reporter = new InMemoryReporter();\n                let tracer = new Tracer(\n                    'test-service-name',\n                    reporter,\n                    new ConstSampler(false),\n                    { logger: new MockLogger() }\n                );\n                let span = tracer.startSpan('initially-unsampled-span');\n                span.setTag('tagKeyOne', 'tagValueOne');\n                span.addTags({\n                    'tagKeyTwo': 'tagValueTwo'\n                });\n                span.log({'logkeyOne': 'logValueOne'});\n\n                tracer._sampler = new ConstSampler(o.sampling);\n                span.setOperationName('sampled-span');\n                span.finish();\n\n                assert.deepEqual(span._tags[0], {key: 'tagKeyOne', value: 'tagValueOne'});\n                assert.deepEqual(span._tags[1], {key: 'tagKeyTwo', value: 'tagValueTwo'});\n                assert.deepEqual(span._logs[0].fields[0], {key: 'logkeyOne', value: 'logValueOne'});\n                assert.equal(reporter.spans.length, o.reportedSpans);\n            });\n        });\n\n        describe('span sampling finalizer', () => {\n            it ('should trigger when it inherits a sampling decision', () => {\n                assert.equal(span.context().samplingFinalized, false, 'Span created in before each is not finalized');\n\n                let childSpan = tracer.startSpan('child-span', {childOf: span});\n                assert.isOk(span.context().samplingFinalized);\n                assert.isOk(childSpan.context().samplingFinalized);\n            });\n\n            it ('should trigger when it sets the sampling priority', () => {\n                // Span created in before each is not finalized.\n                assert.equal(span.context().samplingFinalized, false);\n\n                span.setTag(opentracing.Tags.SAMPLING_PRIORITY, 1);\n                assert.isOk(span.context().samplingFinalized);\n\n                let unsampledSpan = tracer.startSpan('usampled-span');\n                unsampledSpan.setTag(opentracing.Tags.SAMPLING_PRIORITY, -1);\n                assert.isOk(unsampledSpan.context().samplingFinalized);\n            });\n\n            it ('should trigger on a finish()-ed span', () => {\n                // Span created in before each is not finalized.\n                assert.equal(span.context().samplingFinalized, false);\n\n                span.finish();\n                assert.isOk(span.context().samplingFinalized);\n            });\n\n            it ('should trigger after calling setOperationName', () => {\n                // Span created in before each is not finalized.\n                assert.equal(span.context().samplingFinalized, false);\n\n                span.setOperationName('fry');\n                assert.isOk(span.context().samplingFinalized);\n            });\n\n            it ('should trigger when its context is injected into headers', () => {\n                // Span created in before each is not finalized.\n                assert.equal(span.context().samplingFinalized, false);\n\n                let headers = {};\n                tracer.inject(span.context(), opentracing.FORMAT_HTTP_HEADERS, headers);\n\n                assert.isOk(span.context().samplingFinalized);\n            });\n        });\n\n        it ('isWriteable returns true if not finalized, or the span is sampled', () => {\n            tracer = new Tracer(\n                'test-service-name',\n                new InMemoryReporter(),\n                new ConstSampler(false),\n                { logger: new MockLogger() }\n            );\n            let unFinalizedSpan = tracer.startSpan('unFinalizedSpan');\n            assert.equal(unFinalizedSpan.context().samplingFinalized, false);\n            assert.isOk(unFinalizedSpan._isWriteable());\n\n            tracer._sampler = new ConstSampler(true);\n            let sampledSpan = tracer.startSpan('sampled-span');\n\n            sampledSpan.finish();  // finalizes the span\n            assert.isOk(sampledSpan.context().samplingFinalized);\n\n            assert.isOk(sampledSpan._isWriteable());\n        });\n\n        it ('2nd setOperationName should add sampler tags to span, and change operationName', () => {\n            let span = tracer.startSpan('fry');\n\n            assert.equal(span.operationName, 'fry');\n            assert.isOk(JaegerTestUtils.hasTags(span, {\n                'sampler.type': 'const',\n                'sampler.param': true\n            }));\n            tracer._sampler = new ProbabilisticSampler(1.0);\n            span.setOperationName('re-sampled-span');\n\n            assert.equal(span.operationName, 're-sampled-span');\n            assert.isOk(JaegerTestUtils.hasTags(span, {\n                'sampler.type': 'probabilistic',\n                'sampler.param': 1\n            }));\n        });\n\n        it ('2nd setOperationName should not change the sampling tags, but should change the operationName', () => {\n            let span = tracer.startSpan('fry');\n\n            span.setOperationName('new-span-one');\n            assert.equal(span.operationName, 'new-span-one');\n\n            // update sampler to something will always sample\n            tracer._sampler = new ProbabilisticSampler(1.0);\n\n            // The second cal lshould rename the operation name, but\n            // not re-sample the span.  This is because finalize was set \n            // in the first 'setOperationName' call.\n            span.setOperationName('new-span-two');\n\n            assert.equal(span.operationName, 'new-span-two');\n            assert.isOk(JaegerTestUtils.hasTags(span, {\n                'sampler.type': 'const',\n                'sampler.param': true\n            }));\n        });\n    });\n\n    describe('setTag', () => {\n        it('should set a tag, and return a span', () => {\n            let newSpan = span.setTag('key', 'value');\n            assert.isOk(newSpan instanceof Span);\n            assert.isOk(_.isEqual(span._tags[0], {'key': 'key', 'value': 'value'}));\n        });\n    });\n\n    // TODO(oibe) need tests for standard tags, and handlers\n});\n\n"]}