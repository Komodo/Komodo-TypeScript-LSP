{"version":3,"sources":["../../../test/samplers/ratelimiting_sampler_test.js"],"names":["describe","it","initialDate","Date","getTime","clock","useFakeTimers","sampler","i","isTrue","isSampled","equal","maxTracesPerSecond","isNotOk","tags","decision","isFalse","deepEqual","restore","to","throw","otherSampler","isOk","update","limiter"],"mappings":";;AAaA;;AACA;;;;AACA;;;;AACA;;;;;;AAfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOAA,SAAU,4BAAV,EAAwC,YAAM;AAC1CC,OAAG,8BAAH,EAAmC,YAAM;AACrC,YAAIC,cAAc,IAAIC,IAAJ,CAAS,IAAT,EAAc,CAAd,EAAgB,CAAhB,EAAmBC,OAAnB,EAAlB;AACA,YAAIC,QAAQ,gBAAMC,aAAN,CAAoBJ,WAApB,CAAZ;AACA,YAAIK,UAAU,mCAAwB,EAAxB,EAA4B,EAA5B,CAAd;AACA,aAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,EAApB,EAAwBA,GAAxB,EAA6B;AACzB,yBAAOC,MAAP,CAAcF,QAAQG,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;AACH;;AAED,qBAAOC,KAAP,CAAaJ,QAAQK,kBAArB,EAAyC,EAAzC;AACA,qBAAOC,OAAP,CAAeN,QAAQI,KAAR,CAAc,oCAAyB,GAAzB,CAAd,CAAf;;AAEA,YAAIG,OAAO,EAAX;AACA,YAAIC,WAAWR,QAAQG,SAAR,CAAkB,WAAlB,EAA+BI,IAA/B,CAAf;AACA,qBAAOE,OAAP,CAAeD,QAAf,EAAyB,+BAAzB;AACA,qBAAOE,SAAP,CAAiBH,IAAjB,EAAuB,EAAvB,EAA2B,2BAA3B;;AAEAT,gBAAQ,gBAAMC,aAAN,CAAoBJ,cAAc,IAAlC,CAAR;AACAY,eAAO,EAAP;AACAC,mBAAWR,QAAQG,SAAR,CAAkB,WAAlB,EAA+BI,IAA/B,CAAX;AACA,qBAAOL,MAAP,CAAcM,QAAd,EAAwB,8BAAxB;AACA,qBAAOE,SAAP,CAAiBH,IAAjB,EAAuB,EAAC,gBAAgB,cAAjB,EAAiC,iBAAiB,EAAlD,EAAvB;AACAT,cAAMa,OAAN;AACH,KAtBD;;AAwBAjB,OAAI,6DAAJ,EAAmE,YAAM;AACrE,0BAAO,YAAM;AAAE,+CAAwB,CAAC,GAAzB;AAAgC,SAA/C,EAAiDkB,EAAjD,CAAoDC,KAApD,CAA0D,2DAA1D;AACH,KAFD;;AAIAnB,OAAI,4CAAJ,EAAkD,YAAM;AACpD,YAAIM,UAAU,mCAAwB,GAAxB,CAAd;AACA,YAAIc,eAAe,mCAAwB,GAAxB,CAAnB;;AAEA,qBAAOC,IAAP,CAAYf,QAAQI,KAAR,CAAcU,YAAd,CAAZ;AACH,KALD;;AAOApB,OAAI,8CAAJ,EAAoD,YAAM;AACtD,YAAIC,cAAc,IAAIC,IAAJ,CAAS,IAAT,EAAc,CAAd,EAAgB,CAAhB,EAAmBC,OAAnB,EAAlB;AACA,YAAIC,QAAQ,gBAAMC,aAAN,CAAoBJ,WAApB,CAAZ;AACA,YAAIK,UAAU,mCAAwB,GAAxB,EAA6B,CAA7B,CAAd;;AAEA,qBAAOE,MAAP,CAAcF,QAAQG,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;;AAEAL,gBAAQ,gBAAMC,aAAN,CAAoBJ,cAAc,KAAlC,CAAR;AACA,qBAAOO,MAAP,CAAcF,QAAQG,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;AACAL,cAAMa,OAAN;AACH,KAVD;;AAYAjB,OAAI,4BAAJ,EAAkC,YAAM;AACpC,YAAIC,cAAc,IAAIC,IAAJ,CAAS,IAAT,EAAc,CAAd,EAAgB,CAAhB,EAAmBC,OAAnB,EAAlB;AACA,YAAIC,QAAQ,gBAAMC,aAAN,CAAoBJ,WAApB,CAAZ;AACA,YAAIK,UAAU,mCAAwB,GAAxB,EAA6B,CAA7B,CAAd;;AAEA,qBAAOE,MAAP,CAAcF,QAAQG,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;;AAEA,qBAAOM,OAAP,CAAeT,QAAQgB,MAAR,CAAe,GAAf,CAAf,EAAoC,gEAApC;AACA,qBAAOd,MAAP,CAAcF,QAAQgB,MAAR,CAAe,GAAf,CAAd,EAAmC,kEAAnC;;AAEAlB,gBAAQ,gBAAMC,aAAN,CAAoBJ,cAAc,KAAlC,CAAR;AACA,YAAIY,OAAO,EAAX;AACA,qBAAOL,MAAP,CAAcF,QAAQG,SAAR,CAAkB,WAAlB,EAA+BI,IAA/B,CAAd,EAAoD,8BAApD;AACA,qBAAOG,SAAP,CAAiBH,IAAjB,EAAuB,EAAC,gBAAgB,cAAjB,EAAiC,iBAAiB,CAAlD,EAAvB;AACA,qBAAOL,MAAP,CAAcF,QAAQG,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;AACA,qBAAOM,OAAP,CAAeT,QAAQG,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAf,EAAmD,+BAAnD;AACAL,cAAMa,OAAN;AACH,KAjBD;;AAmBAjB,OAAI,yDAAJ,EAA+D,YAAM;AACjE,YAAIuB,UAAU,mCAAwB,GAAxB,CAAd;AACA,0BAAO,YAAM;AAAEA,oBAAQD,MAAR,CAAe,CAAC,GAAhB;AAAuB,SAAtC,EAAwCJ,EAAxC,CAA2CC,KAA3C,CAAiD,2DAAjD;AACH,KAHD;AAIH,CAvED","file":"ratelimiting_sampler_test.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport {assert, expect} from 'chai';\nimport ProbabilisticSampler from '../../src/samplers/probabilistic_sampler.js';\nimport RateLimitingSampler from '../../src/samplers/ratelimiting_sampler.js';\nimport sinon from 'sinon';\n\ndescribe ('RateLimitingSampler should', () => {\n    it('block after threshold is met', () => {\n        let initialDate = new Date(2011,9,1).getTime();\n        let clock = sinon.useFakeTimers(initialDate);\n        let sampler = new RateLimitingSampler(10, 10);\n        for (let i = 0; i < 10; i++) {\n            assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n        }\n\n        assert.equal(sampler.maxTracesPerSecond, 10);\n        assert.isNotOk(sampler.equal(new ProbabilisticSampler(0.5)));\n\n        let tags = {};\n        let decision = sampler.isSampled('operation', tags);\n        assert.isFalse(decision, 'expected decision to be false');\n        assert.deepEqual(tags, {}, 'expected tags to be empty');\n\n        clock = sinon.useFakeTimers(initialDate + 1000);\n        tags = {};\n        decision = sampler.isSampled('operation', tags);\n        assert.isTrue(decision, 'expected decision to be true');\n        assert.deepEqual(tags, {'sampler.type': 'ratelimiting', 'sampler.param': 10});\n        clock.restore();\n    });\n\n    it ('should throw error when initialized with an incorrect value', () => {\n        expect(() => { new RateLimitingSampler(-2.0); }).to.throw('maxTracesPerSecond must be greater than 0.0.  Received -2');\n    });\n\n    it ('should equal another rate limiting sampler', () => {\n        let sampler = new RateLimitingSampler(1.0);\n        let otherSampler = new RateLimitingSampler(1.0);\n\n        assert.isOk(sampler.equal(otherSampler));\n    });\n\n    it ('work with maxCreditsPerSecond smaller than 1', () => {\n        let initialDate = new Date(2011,9,1).getTime();\n        let clock = sinon.useFakeTimers(initialDate);\n        let sampler = new RateLimitingSampler(0.1, 1);\n\n        assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n\n        clock = sinon.useFakeTimers(initialDate + 10000);\n        assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n        clock.restore();\n    });\n\n    it ('should update successfully', () => {\n        let initialDate = new Date(2011,9,1).getTime();\n        let clock = sinon.useFakeTimers(initialDate);\n        let sampler = new RateLimitingSampler(1.0, 1);\n\n        assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n\n        assert.isFalse(sampler.update(1.0), 'updating using the same maxTracesPerSecond should return false');\n        assert.isTrue(sampler.update(2.0), 'updating using a different maxTracesPerSecond should return true');\n\n        clock = sinon.useFakeTimers(initialDate + 20000);\n        let tags = {};\n        assert.isTrue(sampler.isSampled('operation', tags), 'expected decision to be true');\n        assert.deepEqual(tags, {'sampler.type': 'ratelimiting', 'sampler.param': 2});\n        assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n        assert.isFalse(sampler.isSampled('operation', {}), 'expected decision to be false');\n        clock.restore();\n    });\n\n    it ('should throw error when updated with an incorrect value', () => {\n        let limiter = new RateLimitingSampler(2.0);\n        expect(() => { limiter.update(-2.0); }).to.throw('maxTracesPerSecond must be greater than 0.0.  Received -2');\n    });\n});\n"]}