{"version":3,"sources":["../../test/propagators.js"],"names":["constants","describe","it","codec","urlEncoding","_decodeURIValue","value","URIError","strictEqual","_decodeValue","contextKey","ctx","fromString","out","inject","baggagePrefix","carrier","extract","deepEqual","baggage","equal","parentIdStr","spanIdStr","traceIdStr","isSampled","isDebug","isNotOk","withStringIds","flags","DEBUG_MASK","SAMPLED_MASK","isUndefined","withBaggageItem"],"mappings":"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","file":"propagators.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport {assert} from 'chai';\nimport * as constants from '../src/constants';\nimport TextMapCodec from '../src/propagators/text_map_codec';\nimport ZipkinB3TextMapCodec from '../src/propagators/zipkin_b3_text_map_codec';\nimport SpanContext from '../src/span_context';\n\ndescribe ('TextMapCodec', () => {\n    it('should not URL-decode value that has no % meta-characters', () => {\n        let codec = new TextMapCodec({ urlEncoding: true });\n        codec._decodeURIValue = (value: string) => {\n            throw new URIError('fake error');\n        };\n        assert.strictEqual(codec._decodeValue('abc'), 'abc');\n    });\n\n    it('should not throw exception on bad URL-encoded values', () => {\n        let codec = new TextMapCodec({ urlEncoding: true });\n        // this string throws exception when passed to decodeURIComponent\n        assert.strictEqual(codec._decodeValue('%EA'), '%EA');\n    });\n\n    it('should not URL-encode span context', () => {\n        let codec = new TextMapCodec({ urlEncoding: true, contextKey: 'trace-context' });\n        let ctx = SpanContext.fromString('1:1:1:1');\n        let out = {};\n        codec.inject(ctx, out);\n        assert.strictEqual(out['trace-context'], '1:1:1:1');\n    });\n\n    it('should decode baggage', () => {\n        let codec = new TextMapCodec({\n            urlEncoding: true,\n            contextKey: 'trace-context',\n            baggagePrefix: 'baggage-'\n        });\n        let carrier = {\n            'trace-context': '1:1:1:1',\n            'baggage-some-key': 'some-value',\n            'garbage-in': 'garbage-out'\n        };\n        let ctx = codec.extract(carrier);\n        assert.deepEqual(ctx.baggage, { 'some-key': 'some-value' });\n    });\n});\n\ndescribe ('ZipkinB3TextMapCodec', () => {\n    it('correctly extract the zipkin headers from a span context', () => {\n        let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n\n        let carrier = {\n            'x-b3-parentspanid': '123abc',\n            'x-b3-spanid': 'aaafff',\n            'x-b3-traceid': '789fed',\n            'x-b3-sampled': '1',\n            'x-b3-flags': '1',\n            'foo': 'bar'\n        };\n\n        let ctx = codec.extract(carrier);\n        assert.equal(ctx.parentIdStr, '123abc');\n        assert.equal(ctx.spanIdStr, 'aaafff');\n        assert.equal(ctx.traceIdStr, '789fed');\n        assert.equal(ctx.isSampled(), true);\n        assert.equal(ctx.isDebug(), true);\n    });\n\n    it('use an empty context if the zipkin headers contain invalid ids', () => {\n        let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n\n        let carrier = {\n            'x-b3-parentspanid': 'bad-value',\n            'x-b3-spanid': 'another-bad-value',\n            'x-b3-traceid': 'not-a-valid-traceid',\n            'x-b3-sampled': '1',\n            'x-b3-flags': '1',\n            'foo': 'bar'\n        };\n\n        let ctx = codec.extract(carrier);\n        assert.isNotOk(ctx.parentIdStr);\n        assert.isNotOk(ctx.spanIdStr);\n        assert.isNotOk(ctx.traceIdStr);\n        assert.equal(ctx.isSampled(), true);\n        assert.equal(ctx.isDebug(), true);\n    });\n    it('correctly inject the zipkin headers into a span context', () => {\n        let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n        let carrier = {};\n\n        let ctx = SpanContext.withStringIds('789fed', 'aaafff', '123abc');\n        ctx.flags = constants.DEBUG_MASK | constants.SAMPLED_MASK;\n\n        codec.inject(ctx, carrier);\n        assert.equal(carrier['x-b3-traceid'], '789fed');\n        assert.equal(carrier['x-b3-spanid'], 'aaafff');\n        assert.equal(carrier['x-b3-parentspanid'], '123abc');\n        assert.equal(carrier['x-b3-flags'], '1');\n\n        // > Since Debug implies Sampled, so don't also send \"X-B3-Sampled: 1\"\n        // https://github.com/openzipkin/b3-propagation\n        assert.isUndefined(carrier['x-b3-sampled']);\n    });\n\n    it('should not URL-decode value that has no % meta-characters', () => {\n        let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n        codec._decodeURIValue = (value: string) => {\n            throw new URIError('fake error');\n        };\n        assert.strictEqual(codec._decodeValue('abc'), 'abc');\n    });\n\n    it('should not throw exception on bad URL-encoded values', () => {\n        let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n        // this string throws exception when passed to decodeURIComponent\n        assert.strictEqual(codec._decodeValue('%EA'), '%EA');\n    });\n\n    it('should decode baggage', () => {\n        let codec = new ZipkinB3TextMapCodec({\n            urlEncoding: true,\n            contextKey: 'trace-context',\n            baggagePrefix: 'baggage-'\n        });\n        let carrier = {\n            'x-b3-parentspanid': '123abc',\n            'x-b3-spanid': 'aaafff',\n            'x-b3-traceid': '789fed',\n            'baggage-some-key': 'some-value',\n            'garbage-in': 'garbage-out'\n        };\n        let ctx = codec.extract(carrier);\n        assert.deepEqual(ctx.baggage, { 'some-key': 'some-value' });\n    });\n\n    it('should encode baggage', () => {\n        let codec = new ZipkinB3TextMapCodec({\n            urlEncoding: true,\n            contextKey: 'trace-context',\n            baggagePrefix: 'baggage-'\n        });\n        let carrier = {};\n\n        let ctx = SpanContext.withStringIds('789fed', 'aaafff', '123abc');\n        ctx = ctx.withBaggageItem('some-key', 'some-value');\n        ctx = ctx.withBaggageItem('another-key', 'another-value');\n\n        codec.inject(ctx, carrier);\n        assert.equal(carrier['baggage-some-key'], 'some-value');\n        assert.equal(carrier['baggage-another-key'], 'another-value');\n    });\n});\n"]}