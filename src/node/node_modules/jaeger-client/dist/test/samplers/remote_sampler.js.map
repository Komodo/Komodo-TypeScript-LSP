{"version":3,"sources":["../../../test/samplers/remote_sampler.js"],"names":["describe","server","logger","metrics","remoteSampler","before","start","after","close","beforeEach","clearStrategies","refreshInterval","afterEach","it","done","samplerQueryFailure","increment","equal","_errorMsgs","length","_host","_refreshSamplingStrategy","badResponses","forEach","resp","samplerParsingFailure","addStrategy","_serviceName","_onSamplerUpdate","s","_samplingRate","counterValue","samplerRetrieved","samplerUpdated","firstSampler","strictEqual","strategyType","probabilisticSampling","samplingRate","maxTracesPerSecond","isOk","rateLimitingSampling","rateLimitingSampler","_sampler","operationSampling","defaultSamplingProbability","defaultLowerBoundTracesPerSecond","perOperationStrategies","s2","clock","useFakeTimers","sampler","onSamplerUpdate","notEqual","isTrue","toString","restore","tick"],"mappings":"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","file":"remote_sampler.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport {assert} from 'chai';\nimport sinon from 'sinon';\nimport Metrics from '../../src/metrics/metrics.js';\nimport RateLimitingSampler from '../../src/samplers/ratelimiting_sampler';\nimport ProbabilisticSampler from '../../src/samplers/probabilistic_sampler.js';\nimport PerOperationSampler from '../../src/samplers/per_operation_sampler';\nimport RemoteSampler from '../../src/samplers/remote_sampler';\nimport MockLogger from '../lib/mock_logger';\nimport SamplingServer from '../lib/sampler_server';\nimport LocalMetricFactory from '../lib/metrics/local/metric_factory.js';\nimport LocalBackend from '../lib/metrics/local/backend.js';\n\ndescribe('RemoteSampler', () => {\n    let server: SamplingServer;\n    let logger: MockLogger;\n    let metrics: Metrics;\n    let remoteSampler: RemoteSampler;\n\n    before(() => {\n        server = new SamplingServer().start();\n    });\n\n    after(() => {\n        server.close();\n    });\n\n    beforeEach(() => {\n        server.clearStrategies();\n        logger = new MockLogger();\n        metrics = new Metrics(new LocalMetricFactory());\n        remoteSampler = new RemoteSampler('service1', {\n            refreshInterval: 0,\n            metrics: metrics,\n            logger: logger\n        });\n    });\n\n    afterEach(() => {\n        remoteSampler.close();\n    });\n\n    it ('should log metric on failing to query for sampling strategy', (done) => {\n        metrics.samplerQueryFailure.increment = function() {\n            assert.equal(logger._errorMsgs.length, 1, `errors=${logger._errorMsgs}`);\n            done();\n        };\n        remoteSampler._host = 'fake-host';\n        remoteSampler._refreshSamplingStrategy();\n    });\n\n    let badResponses: Array<any> = ['junk', '0', 'false', {}];\n    badResponses.forEach((resp) => {\n        it (`should log metric on failing to parse bad http response ${resp}`, (done) => {\n            metrics.samplerParsingFailure.increment = function() {\n                assert.equal(logger._errorMsgs.length, 1, `errors=${logger._errorMsgs}`);\n                done();\n            };\n            server.addStrategy('service1', resp);\n            remoteSampler._refreshSamplingStrategy();\n        });\n    });\n\n    it('should throw error on bad sampling strategy', (done) => {\n        metrics.samplerParsingFailure.increment = function() {\n            assert.equal(logger._errorMsgs.length, 1);\n            done();\n        };\n        remoteSampler._serviceName = 'bad-service';\n        remoteSampler._refreshSamplingStrategy();\n    });\n\n    it('should set probabilistic sampler, but only once', (done) => {\n        remoteSampler._onSamplerUpdate = (s) => {\n            assert.equal(s._samplingRate, 1.0);\n            assert.equal(LocalBackend.counterValue(metrics.samplerRetrieved), 1);\n            assert.equal(LocalBackend.counterValue(metrics.samplerUpdated), 1);\n\n            let firstSampler = s;\n\n            // prepare for second update\n            remoteSampler._onSamplerUpdate = (s) => {\n                assert.strictEqual(s, firstSampler, 'must not have changed the sampler');\n\n                assert.equal(LocalBackend.counterValue(metrics.samplerRetrieved), 2);\n                assert.equal(LocalBackend.counterValue(metrics.samplerUpdated), 1);\n\n                // prepare for third update - for test coverage only\n                remoteSampler._onSamplerUpdate = null;\n                remoteSampler._refreshSamplingStrategy();\n\n                done();\n            };\n\n            remoteSampler._refreshSamplingStrategy();\n        };\n        server.addStrategy('service1', {\n            strategyType: 'PROBABILISTIC',\n            probabilisticSampling: {\n                samplingRate: 1.0\n            }\n        });\n        remoteSampler._refreshSamplingStrategy();\n    });\n\n    it('should set ratelimiting sampler', (done) => {\n        let maxTracesPerSecond = 10;\n        remoteSampler._onSamplerUpdate = (s) => {\n            assert.isOk(s.equal(new RateLimitingSampler(maxTracesPerSecond)));\n            done();\n        };\n        server.addStrategy('service1', {\n            strategyType: 'RATE_LIMITING',\n            rateLimitingSampling: {\n                maxTracesPerSecond: maxTracesPerSecond\n            }\n        });\n        remoteSampler._refreshSamplingStrategy();\n    });\n\n    it('should update ratelimiting sampler', (done) => {\n        let rateLimitingSampler = new RateLimitingSampler(10);\n        remoteSampler._sampler = rateLimitingSampler;\n        let maxTracesPerSecond = 5;\n        remoteSampler._onSamplerUpdate = (s) => {\n            assert.strictEqual(rateLimitingSampler, remoteSampler._sampler);\n            assert.isOk(s.equal(new RateLimitingSampler(maxTracesPerSecond)));\n            done();\n        };\n        server.addStrategy('service1', {\n            strategyType: 'RATE_LIMITING',\n            rateLimitingSampling: {\n                maxTracesPerSecond: maxTracesPerSecond\n            }\n        });\n        remoteSampler._refreshSamplingStrategy();\n    });\n\n    it('should set per-operation sampler', (done) => {\n        server.addStrategy('service1', {\n            strategyType: 'PROBABILISTIC',\n            probabilisticSampling: {\n                samplingRate: 1.0\n            },\n            operationSampling: {\n                defaultSamplingProbability: 0.05,\n                defaultLowerBoundTracesPerSecond: 0.1,\n                perOperationStrategies: []\n            }\n        });\n        remoteSampler._onSamplerUpdate = (s) => {\n            assert.isOk(s instanceof PerOperationSampler);\n            assert.equal(LocalBackend.counterValue(metrics.samplerRetrieved), 1);\n            assert.equal(LocalBackend.counterValue(metrics.samplerUpdated), 1);\n\n            // cause a second refresh without changes\n            remoteSampler._onSamplerUpdate = (s2) => {\n                assert.strictEqual(s2, s);\n                assert.equal(LocalBackend.counterValue(metrics.samplerRetrieved), 2, 'second retrieval');\n                assert.equal(LocalBackend.counterValue(metrics.samplerUpdated), 1, 'but no update');\n                done();\n            };\n            remoteSampler._refreshSamplingStrategy();\n        };\n        remoteSampler._refreshSamplingStrategy();\n    });\n\n    it('should refresh periodically', (done) => {\n        server.addStrategy('service1', {\n            strategyType: 'PROBABILISTIC',\n            probabilisticSampling: {\n                samplingRate: 0.777\n            }\n        });\n\n        let clock: any = sinon.useFakeTimers();\n\n        let sampler = new RemoteSampler('service1', {\n            refreshInterval: 10, // 10ms\n            metrics: metrics,\n            logger: logger,\n            onSamplerUpdate: (s) => {\n                assert.notEqual(LocalBackend.counterValue(metrics.samplerRetrieved), 0);\n                assert.notEqual(LocalBackend.counterValue(metrics.samplerUpdated), 0);\n                assert.equal(logger._errorMsgs.length, 0, 'number of error logs');\n                assert.isTrue(sampler._sampler.equal(new ProbabilisticSampler(0.777)), sampler._sampler.toString());\n\n                clock.restore();\n\n                sampler._onSamplerUpdate = null;\n                sampler.close(done);\n            }\n        });\n\n        clock.tick(20);\n    });\n});\n"]}