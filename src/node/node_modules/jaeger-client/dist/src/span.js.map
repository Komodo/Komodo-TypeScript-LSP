{"version":3,"sources":["../../src/span.js"],"names":["constants","opentracing","Span","tracer","operationName","spanContext","startTime","references","_tracer","_operationName","_spanContext","_startTime","_logger","_references","_baggageSetter","_logs","_tags","key","baggageHeaderCache","_getBaggageHeaderCache","normalizedKey","replace","toLowerCase","Object","keys","length","value","_normalizeBaggageKey","setBaggage","baggage","samplingFinalized","isSampled","sampler","_sampler","tags","flags","SAMPLED_MASK","addTags","finalizeSampling","finishTime","_duration","undefined","spanInfo","context","toString","error","endTime","now","_report","keyValuePairs","Tags","SAMPLING_PRIORITY","_setSamplingPriority","_isWriteable","hasOwnProperty","push","timestamp","convertObjectToTags","eventName","payload","log","event","priority","DEBUG_MASK","_serviceName","_baggageHeaderCache"],"mappings":"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","file":"span.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport * as constants from './constants.js';\nimport SpanContext from './span_context.js';\nimport * as opentracing from 'opentracing';\nimport Utils from './util.js';\nimport BaggageSetter from './baggage/baggage_setter';\n\nexport default class Span {\n    _tracer: any;\n    _operationName: string;\n    _spanContext: SpanContext;\n    _startTime: number;\n    _logger: any;\n    _duration: number;\n    _logs: Array<LogData>;\n    _tags: Array<Tag>;\n    static _baggageHeaderCache: any;\n    _references: Array<Reference>;\n    _baggageSetter: BaggageSetter;\n\n    constructor(tracer: any,\n                operationName: string,\n                spanContext: SpanContext,\n                startTime: number,\n                references: Array<Reference>\n    ) {\n        this._tracer = tracer;\n        this._operationName = operationName;\n        this._spanContext = spanContext;\n        this._startTime = startTime;\n        this._logger = tracer._logger;\n        this._references = references;\n        this._baggageSetter = tracer._baggageSetter;\n        this._logs = [];\n        this._tags = [];\n    }\n\n    get operationName(): string {\n        return this._operationName;\n    }\n\n    get serviceName(): string {\n        return this._tracer._serviceName;\n    }\n\n    static _getBaggageHeaderCache() {\n        if (!Span._baggageHeaderCache) {\n            Span._baggageHeaderCache = {};\n        }\n\n        return Span._baggageHeaderCache;\n    }\n\n    /**\n     * Returns a normalize key.\n     *\n     * @param {string} key - The key to be normalized for a particular baggage value.\n     * @return {string} - The normalized key (lower cased and underscores replaced, along with dashes.)\n     **/\n    _normalizeBaggageKey(key: string) {\n        let baggageHeaderCache = Span._getBaggageHeaderCache();\n        if (key in baggageHeaderCache) {\n            return baggageHeaderCache[key];\n        }\n\n        let normalizedKey: string = key.replace(/_/g, '-').toLowerCase();\n\n        if (Object.keys(baggageHeaderCache).length < 100) {\n            baggageHeaderCache[key] = normalizedKey;\n        }\n\n        return normalizedKey;\n    }\n\n    /**\n     * Sets a baggage value with an associated key.\n     *\n     * @param {string} key - The baggage key.\n     * @param {string} value - The baggage value.\n     *\n     * @return {Span} - returns this span.\n     **/\n    setBaggageItem(key: string, value: string): Span {\n        let normalizedKey = this._normalizeBaggageKey(key);\n\n        // We create a new instance of the context here instead of just adding\n        // another entry to the baggage dictionary. By doing so we keep the\n        // baggage immutable so that it can be passed to children spans as is.\n        // If it was mutable, we would have to make a copy of the dictionary\n        // for every child span, which on average we expect to occur more\n        // frequently than items being added to the baggage.\n        this._spanContext = this._baggageSetter.setBaggage(this, normalizedKey, value);\n        return this;\n    }\n\n    /**\n     * Gets a baggage value with an associated key.\n     *\n     * @param {string} key - The baggage key.\n     * @return {string} value - The baggage value.\n     **/\n    getBaggageItem(key: string): string {\n        let normalizedKey = this._normalizeBaggageKey(key);\n        return this._spanContext.baggage[normalizedKey];\n    }\n\n    /**\n     * Returns the span context that represents this span.\n     *\n     * @return {SpanContext} - Returns this span's span context.\n     **/\n    context(): SpanContext {\n        return this._spanContext;\n    }\n\n    /**\n     * Returns the tracer associated with this span.\n        this._duration;\n     * @return {Tracer} - returns the tracer associated witht this span.\n     **/\n    tracer(): any {\n        return this._tracer;\n    }\n\n    /**\n     * Checks whether or not a span can be written to.\n     *\n     * @return {boolean} - The decision about whether this span can be written to.\n     **/\n    _isWriteable(): boolean {\n        return !this._spanContext.samplingFinalized || this._spanContext.isSampled();\n    }\n\n    /**\n     * Sets the operation name on this given span.\n     *\n     * @param {string} name - The name to use for setting a span's operation name.\n     * @return {Span} - returns this span.\n     **/\n    setOperationName(operationName: string): Span {\n        this._operationName = operationName;\n        // We re-sample the span if it has not been finalized.\n        if (this._spanContext.samplingFinalized) {\n            return this;\n        }\n\n        let sampler = this.tracer()._sampler;\n        let tags = {};\n        if (sampler.isSampled(operationName, tags)) {\n            this._spanContext.flags |= constants.SAMPLED_MASK;\n            this.addTags(tags);\n        }\n        this._spanContext.finalizeSampling();\n\n        return this;\n    }\n\n    /**\n     * Sets the end timestamp and finalizes Span state.\n     *\n     * With the exception of calls to Span.context() (which are always allowed),\n     * finish() must be the last call made to any span instance, and to do\n     * otherwise leads to undefined behavior.\n     *\n     * @param  {number} finishTime\n     *         Optional finish time in milliseconds as a Unix timestamp. Decimal\n     *         values are supported for timestamps with sub-millisecond accuracy.\n     *         If not specified, the current time (as defined by the\n     *         implementation) will be used.\n     */\n    finish(finishTime: ?number): void {\n        if (this._duration !== undefined) {\n            let spanInfo = `operation=${this.operationName},context=${this.context().toString()}`;\n            this.tracer()._logger.error(`${spanInfo}#You can only call finish() on a span once.`);\n            return;\n        }\n\n        this._spanContext.finalizeSampling();\n        if (this._spanContext.isSampled()) {\n            let endTime = finishTime || this._tracer.now();\n            this._duration = endTime - this._startTime;\n            this._tracer._report(this);\n        }\n    }\n\n    /**\n     * Adds a set of tags to a span.\n     *\n     * @param {Object} keyValuePairs - An object with key value pairs\n     * that represent tags to be added to this span.\n     * @return {Span} - returns this span.\n     **/\n    addTags(keyValuePairs: any): Span {\n        if (opentracing.Tags.SAMPLING_PRIORITY in keyValuePairs) {\n            this._setSamplingPriority(keyValuePairs[opentracing.Tags.SAMPLING_PRIORITY]);\n            delete keyValuePairs[opentracing.Tags.SAMPLING_PRIORITY];\n        }\n\n        if (this._isWriteable()) {\n            for (let key in keyValuePairs) {\n                if (keyValuePairs.hasOwnProperty(key)) {\n                    let value = keyValuePairs[key];\n                    this._tags.push({'key': key, 'value': value});\n                }\n            }\n        }\n        return this;\n    }\n\n    /**\n     * Adds a single tag to a span\n     *\n     * @param {string} key - The key for the tag added to this span.\n     * @param {string} value - The value corresponding with the key\n     * for the tag added to this span.\n     * @return {Span} - returns this span.\n     * */\n    setTag(key: string, value: any): Span {\n        if (key === opentracing.Tags.SAMPLING_PRIORITY) {\n            this._setSamplingPriority(value);\n            return this;\n        }\n\n        if (this._isWriteable()) {\n            this._tags.push({'key': key, 'value': value});\n        }\n        return this;\n    }\n\n    /**\n     * Adds a log event, or payload to a span.\n     *\n     * @param {object} keyValuePairs\n     *        An object mapping string keys to arbitrary value types. All\n     *        Tracer implementations should support bool, string, and numeric\n     *        value types, and some may also support Object values.\n     * @param {number} timestamp\n     *        An optional parameter specifying the timestamp in milliseconds\n     *        since the Unix epoch. Fractional values are allowed so that\n     *        timestamps with sub-millisecond accuracy can be represented. If\n     *        not specified, the implementation is expected to use its notion\n     *        of the current time of the call.\n     */\n    log(keyValuePairs: any, timestamp: ?number): void {\n        if (this._isWriteable()) {\n            this._logs.push({\n                'timestamp': timestamp || this._tracer.now(),\n                'fields': Utils.convertObjectToTags(keyValuePairs)\n            });\n        }\n    }\n\n    /**\n     * Logs a event with an optional payload.\n     *\n     * @param  {string} eventName - string associated with the log record\n     * @param  {object} [payload] - arbitrary payload object associated with the\n     *         log record.\n     */\n    logEvent(eventName: string, payload: any): void {\n        return this.log({\n            event: eventName,\n            payload: payload\n        });\n    }\n\n    _setSamplingPriority(priority: number): void {\n        if (priority > 0) {\n            this._spanContext.flags = this._spanContext.flags | constants.SAMPLED_MASK | constants.DEBUG_MASK;\n        } else {\n            this._spanContext.flags = this._spanContext.flags & (~constants.SAMPLED_MASK);\n        }\n        this._spanContext.finalizeSampling();\n    }\n}\n"]}