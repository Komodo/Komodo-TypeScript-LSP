{"version":3,"sources":["../../../src/samplers/remote_sampler.js"],"names":["DEFAULT_INITIAL_SAMPLING_RATE","DEFAULT_REFRESH_INTERVAL","DEFAULT_MAX_OPERATIONS","DEFAULT_SAMPLING_HOST","DEFAULT_SAMPLING_PORT","PROBABILISTIC_STRATEGY_TYPE","RATELIMITING_STRATEGY_TYPE","RemoteControlledSampler","serviceName","options","_serviceName","_sampler","sampler","_logger","logger","_metrics","metrics","_refreshInterval","refreshInterval","_host","host","_port","port","_maxOperations","maxOperations","_onSamplerUpdate","onSamplerUpdate","randomDelay","Math","random","_initialDelayTimeoutHandle","setTimeout","_afterInitialDelay","bind","name","_refreshIntervalHandle","setInterval","_refreshSamplingStrategy","encodeURIComponent","get","res","setEncoding","body","on","chunk","_parseSamplingServerResponse","err","error","samplerQueryFailure","increment","samplerRetrieved","strategy","JSON","parse","samplerParsingFailure","_updateSampler","samplerUpdated","response","operationSampling","update","newSampler","strategyType","probabilisticSampling","samplingRate","rateLimitingSampling","maxTracesPerSecond","stringify","equal","operation","tags","isSampled","callback","clearTimeout","clearInterval"],"mappings":"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","file":"remote_sampler.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport http from 'http';\nimport ProbabilisticSampler from './probabilistic_sampler.js';\nimport RateLimitingSampler from './ratelimiting_sampler.js';\nimport PerOperationSampler from './per_operation_sampler.js';\nimport Metrics from '../metrics/metrics.js';\nimport NullLogger from '../logger.js';\nimport NoopMetricFactory from '../metrics/noop/metric_factory';\n\nconst DEFAULT_INITIAL_SAMPLING_RATE = 0.001;\nconst DEFAULT_REFRESH_INTERVAL = 60000;\nconst DEFAULT_MAX_OPERATIONS = 2000;\nconst DEFAULT_SAMPLING_HOST = '0.0.0.0';\nconst DEFAULT_SAMPLING_PORT = 5778;\nconst PROBABILISTIC_STRATEGY_TYPE = 'PROBABILISTIC';\nconst RATELIMITING_STRATEGY_TYPE = 'RATE_LIMITING';\n\nexport default class RemoteControlledSampler {\n\n    _serviceName: string;\n    _sampler: Sampler;\n    _logger: Logger;\n    _metrics: Metrics;\n\n    _refreshInterval: number;\n    _host: string;\n    _port: number;\n    _maxOperations: number;\n\n    _onSamplerUpdate: ?Function;\n\n    _initialDelayTimeoutHandle: any;\n    _refreshIntervalHandle: any;\n\n    /**\n     * Creates a sampler remotely controlled by jaeger-agent.\n     *\n     * @param {string} [serviceName] - name of the current service / application, same as given to Tracer\n     * @param {object} [options] - optional settings\n     * @param {object} [options.sampler] - initial sampler to use prior to retrieving strategies from Agent\n     * @param {object} [options.logger] - optional logger, see _flow/logger.js\n     * @param {object} [options.metrics] - instance of Metrics object\n     * @param {number} [options.refreshInterval] - interval in milliseconds before sampling strategy refreshes (0 to not refresh)\n     * @param {string} [options.host] - host for jaeger-agent, defaults to 'localhost'\n     * @param {number} [options.port] - port for jaeger-agent for SamplingManager endpoint\n     * @param {number} [options.maxOperations] - max number of operations to track in PerOperationSampler\n     * @param {function} [options.onSamplerUpdate]\n     */\n    constructor(serviceName: string, options: any = {}) {\n        this._serviceName = serviceName;\n        this._sampler = options.sampler || new ProbabilisticSampler(DEFAULT_INITIAL_SAMPLING_RATE);\n        this._logger = options.logger || new NullLogger();\n        this._metrics = options.metrics || new Metrics(new NoopMetricFactory());\n        this._refreshInterval = options.refreshInterval || DEFAULT_REFRESH_INTERVAL;\n        this._host = options.host || DEFAULT_SAMPLING_HOST;\n        this._port = options.port || DEFAULT_SAMPLING_PORT;\n        this._maxOperations = options.maxOperations || DEFAULT_MAX_OPERATIONS;\n\n        this._onSamplerUpdate = options.onSamplerUpdate;\n\n        if (options.refreshInterval !== 0) {\n            let randomDelay: number = Math.random() * this._refreshInterval;\n            this._initialDelayTimeoutHandle = setTimeout(this._afterInitialDelay.bind(this), randomDelay);\n        }\n    }\n\n    name(): string {\n        return 'RemoteSampler';\n    }\n\n    toString(): string {\n        return `${this.name()}(serviceName=${this._serviceName})`;\n    }\n\n    _afterInitialDelay(): void {\n        this._refreshIntervalHandle = setInterval(\n            this._refreshSamplingStrategy.bind(this),\n            this._refreshInterval\n        );\n    }\n\n    _refreshSamplingStrategy() {\n        let serviceName: string = encodeURIComponent(this._serviceName);\n        http.get({\n            'host': this._host,\n            'port': this._port,\n            'path': `/sampling?service=${serviceName}`\n        }, (res) => {\n            // explicitly treat incoming data as utf8 (avoids issues with multi-byte chars)\n            res.setEncoding('utf8');\n\n            // incrementally capture the incoming response body\n            let body = '';\n            res.on('data', (chunk) => {\n                body += chunk;\n            });\n\n            res.on('end', () => {\n                this._parseSamplingServerResponse(body);\n            });\n        }).on('error', (err) => {\n            this._logger.error(`Error in fetching sampling strategy: ${err}.`);\n            this._metrics.samplerQueryFailure.increment(1);\n        });\n    }\n\n    _parseSamplingServerResponse(body: string) {\n        this._metrics.samplerRetrieved.increment(1);\n        let strategy;\n        try {\n            strategy = JSON.parse(body);\n            if (!strategy) {\n                throw 'Malformed response: ' + body;\n            }\n        } catch (error) {\n            this._logger.error(`Error in parsing sampling strategy: ${error}.`);\n            this._metrics.samplerParsingFailure.increment(1);\n            return;\n        }\n        try {\n            if (this._updateSampler(strategy)) {\n                this._metrics.samplerUpdated.increment(1);\n            }\n        } catch (error) {\n            this._logger.error(`Error in updating sampler: ${error}.`);\n            this._metrics.samplerParsingFailure.increment(1);\n            return;\n        }\n        if (this._onSamplerUpdate) {\n            this._onSamplerUpdate(this._sampler);\n        }\n    }\n\n    _updateSampler(response: SamplingStrategyResponse): boolean {\n        if (response.operationSampling) {\n            if (this._sampler instanceof PerOperationSampler) {\n                let sampler: PerOperationSampler = this._sampler;\n                return sampler.update(response.operationSampling);\n            }\n            this._sampler = new PerOperationSampler(response.operationSampling, this._maxOperations);\n            return true;\n        }\n        let newSampler: Sampler;\n        if (response.strategyType === PROBABILISTIC_STRATEGY_TYPE && response.probabilisticSampling) {\n            let samplingRate = response.probabilisticSampling.samplingRate;\n            newSampler = new ProbabilisticSampler(samplingRate);\n        } else if (response.strategyType === RATELIMITING_STRATEGY_TYPE && response.rateLimitingSampling) {\n            let maxTracesPerSecond = response.rateLimitingSampling.maxTracesPerSecond;\n            if (this._sampler instanceof RateLimitingSampler) {\n                let sampler: RateLimitingSampler = this._sampler;\n                return sampler.update(maxTracesPerSecond);\n            }\n            this._sampler = new RateLimitingSampler(maxTracesPerSecond);\n            return true;\n        } else {\n            throw 'Malformed response: ' + JSON.stringify(response);\n        }\n\n        if (this._sampler.equal(newSampler)) {\n            return false;\n        }\n        this._sampler = newSampler;\n        return true;\n    }\n\n\n    isSampled(operation: string, tags: any): boolean {\n        return this._sampler.isSampled(operation, tags);\n    }\n\n    close(callback: ?Function): void {\n        clearTimeout(this._initialDelayTimeoutHandle);\n        clearInterval(this._refreshIntervalHandle);\n\n        if (callback) {\n            callback();\n        }\n    }\n}\n"]}