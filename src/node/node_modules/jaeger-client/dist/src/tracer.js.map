{"version":3,"sources":["../../src/tracer.js"],"names":["constants","opentracing","Tracer","serviceName","reporter","sampler","options","_tags","tags","JAEGER_CLIENT_VERSION_TAG_KEY","version","TRACER_HOSTNAME_TAG_KEY","hostname","PROCESS_IP","ipToInt","myIp","_metrics","metrics","_serviceName","_reporter","_sampler","_logger","logger","_baggageSetter","baggageRestrictionManager","_injectors","_extractors","textCodec","urlEncoding","registerInjector","FORMAT_TEXT_MAP","registerExtractor","httpCodec","FORMAT_HTTP_HEADERS","binaryCodec","FORMAT_BINARY","setProcess","convertObjectToTags","spanContext","operationName","startTime","userTags","internalTags","parentContext","rpcServer","references","hadParent","isDebugIDContainerOnly","span","addTags","spansStarted","increment","context","isSampled","spansSampled","tracesStartedSampled","tracesJoinedSampled","spansNotSampled","tracesStartedNotSampled","tracesJoinedNotSampled","spansFinished","report","format","injector","extractor","now","followsFromIsParent","parent","childOf","i","length","ref","type","REFERENCE_CHILD_OF","referencedContext","REFERENCE_FOLLOWS_FROM","spanKindValue","SPAN_KIND","SPAN_KIND_RPC_SERVER","ctx","isValid","randomId","getRandom64","flags","SAMPLED_MASK","DEBUG_MASK","JAEGER_DEBUG_HEADER","debugId","baggage","traceId","spanId","parentId","finalizeSampling","_startInternalSpan","carrier","Error","inject","extract","callback","close","Date"],"mappings":"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","file":"tracer.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport BinaryCodec from './propagators/binary_codec';\nimport ConstSampler from './samplers/const_sampler';\nimport * as constants from './constants';\nimport * as opentracing from 'opentracing';\nimport pjson from '../package.json';\nimport {Tags as opentracing_tags} from 'opentracing';\nimport NoopReporter from './reporters/noop_reporter';\nimport Span from './span';\nimport SpanContext from './span_context';\nimport TextMapCodec from './propagators/text_map_codec';\nimport NullLogger from './logger';\nimport Utils from './util';\nimport Metrics from './metrics/metrics';\nimport NoopMetricFactory from './metrics/noop/metric_factory';\nimport DefaultBaggageRestrictionManager from './baggage/default_baggage_restriction_manager';\nimport os from 'os';\nimport BaggageSetter from './baggage/baggage_setter';\n\nexport default class Tracer {\n    _serviceName: string;\n    _reporter: Reporter;\n    _sampler: Sampler;\n    _logger: NullLogger;\n    _tags: any;\n    _injectors: any;\n    _extractors: any;\n    _metrics: any;\n    _baggageSetter: BaggageSetter;\n\n    /**\n     * @param {String} [serviceName] - name of the current service or application.\n     * @param {Object} [reporter] - reporter used to submit finished spans to Jaeger backend.\n     * @param {Object} [sampler] - sampler used to decide if trace should be sampled when starting a new one.\n     * @param {Object} [options] - the fields to set on the newly created span.\n     * @param {Object} [options.tags] - set of key-value pairs which will be set\n     *        as process-level tags on the Tracer itself.\n     * @param {Object} [options.metrics] - instance of the Metrics class from ./metrics/metrics.js.\n     * @param {Object} [options.logger] - a logger matching NullLogger API from ./logger.js.\n     * @param {Object} [options.baggageRestrictionManager] - a baggageRestrictionManager matching\n     * BaggageRestrictionManager API from ./baggage.js.\n     */\n    constructor(serviceName: string,\n            reporter: Reporter = new NoopReporter(),\n            sampler: Sampler = new ConstSampler(false),\n            options: any = {}) {\n        this._tags = options.tags || {};\n        this._tags[constants.JAEGER_CLIENT_VERSION_TAG_KEY] = `Node-${pjson.version}`;\n        this._tags[constants.TRACER_HOSTNAME_TAG_KEY] = os.hostname();\n        this._tags[constants.PROCESS_IP] = Utils.ipToInt(Utils.myIp());\n\n        this._metrics = options.metrics || new Metrics(new NoopMetricFactory());\n\n        this._serviceName = serviceName;\n        this._reporter = reporter;\n        this._sampler = sampler;\n        this._logger = options.logger || new NullLogger();\n        this._baggageSetter = new BaggageSetter(\n            options.baggageRestrictionManager || new DefaultBaggageRestrictionManager(),\n            this._metrics);\n        this._injectors = {};\n        this._extractors = {};\n\n        let textCodec = new TextMapCodec({\n            urlEncoding: false,\n            metrics: this._metrics\n        });\n        this.registerInjector(opentracing.FORMAT_TEXT_MAP, textCodec);\n        this.registerExtractor(opentracing.FORMAT_TEXT_MAP, textCodec);\n\n        let httpCodec = new TextMapCodec({\n            urlEncoding: true,\n            metrics: this._metrics\n        });\n        this.registerInjector(opentracing.FORMAT_HTTP_HEADERS, httpCodec);\n        this.registerExtractor(opentracing.FORMAT_HTTP_HEADERS, httpCodec);\n\n        let binaryCodec = new BinaryCodec();\n        this.registerInjector(opentracing.FORMAT_BINARY, binaryCodec);\n        this.registerExtractor(opentracing.FORMAT_BINARY, binaryCodec);\n\n        this._reporter.setProcess(this._serviceName, Utils.convertObjectToTags(this._tags));\n    }\n\n    _startInternalSpan(\n        spanContext: SpanContext,\n        operationName: string,\n        startTime: number,\n        userTags: any,\n        internalTags: any,\n        parentContext: ?SpanContext,\n        rpcServer: boolean,\n        references: Array<Reference>): Span {\n\n        let hadParent = parentContext && !parentContext.isDebugIDContainerOnly();\n        let span = new Span(\n            this,\n            operationName,\n            spanContext,\n            startTime,\n            references\n        );\n\n        span.addTags(userTags);\n        span.addTags(internalTags);\n\n        // emit metrics\n        this._metrics.spansStarted.increment(1);\n        if (span.context().isSampled()) {\n            this._metrics.spansSampled.increment(1);\n            if (!hadParent) {\n                this._metrics.tracesStartedSampled.increment(1);\n            } else if (rpcServer) {\n                this._metrics.tracesJoinedSampled.increment(1);\n            }\n        } else {\n            this._metrics.spansNotSampled.increment(1);\n            if (!hadParent) {\n                this._metrics.tracesStartedNotSampled.increment(1);\n            } else if (rpcServer) {\n                this._metrics.tracesJoinedNotSampled.increment(1);\n            }\n        }\n\n        return span;\n    }\n\n    _report(span: Span): void {\n        this._metrics.spansFinished.increment(1);\n        this._reporter.report(span);\n    }\n\n    registerInjector(format: string, injector: Injector): void {\n        this._injectors[format] = injector;\n    }\n\n    registerExtractor(format: string, extractor: Extractor): void {\n        this._extractors[format] = extractor;\n    }\n\n    /**\n    * The method for creating a root or child span.\n    *\n    * @param {string} operationName - the name of the operation.\n    * @param {object} [options] - the fields to set on the newly created span.\n    * @param {string} options.operationName - the name to use for the newly\n    *        created span. Required if called with a single argument.\n    * @param {SpanContext} [options.childOf] - a parent SpanContext (or Span,\n    *        for convenience) that the newly-started span will be the child of\n    *        (per REFERENCE_CHILD_OF). If specified, `fields.references` must\n    *        be unspecified.\n    * @param {array} [options.references] - an array of Reference instances,\n    *        each pointing to a causal parent SpanContext. If specified,\n    *        `fields.childOf` must be unspecified.\n    * @param {object} [options.tags] - set of key-value pairs which will be set\n    *        as tags on the newly created Span. Ownership of the object is\n    *        passed to the created span for efficiency reasons (the caller\n    *        should not modify this object after calling startSpan).\n    * @param {number} [options.startTime] - a manually specified start time for\n    *        the created Span object. The time should be specified in\n    *        milliseconds as Unix timestamp. Decimal value are supported\n    *        to represent time values with sub-millisecond accuracy.\n    * @return {Span} - a new Span object.\n    **/\n    startSpan(operationName: string, options: ?startSpanOptions): Span {\n        // Convert options.childOf to options.references as needed.\n        options = options || {};\n        let references = options.references || [];\n\n        let userTags = options.tags || {};\n        let startTime = options.startTime || this.now();\n\n        // This flag is used to ensure that CHILD_OF reference is preferred \n        // as a parent even if it comes after FOLLOWS_FROM reference.\n        let followsFromIsParent = false;\n        let parent: ?SpanContext = options.childOf instanceof Span ? options.childOf.context() : options.childOf;\n        // If there is no childOf in options, then search list of references\n        for (let i = 0; i < references.length; i++) {\n            let ref: Reference = references[i];\n            if (ref.type() === opentracing.REFERENCE_CHILD_OF) {\n                if (!parent || followsFromIsParent) {\n                    parent = ref.referencedContext();\n                    break;\n                }\n            } else if (ref.type() === opentracing.REFERENCE_FOLLOWS_FROM) {\n                if (!parent) {\n                    parent = ref.referencedContext();\n                    followsFromIsParent = true;\n                }\n            }\n        }\n\n        let spanKindValue = userTags[opentracing_tags.SPAN_KIND];\n        let rpcServer = (spanKindValue === opentracing_tags.SPAN_KIND_RPC_SERVER);\n\n        let ctx: SpanContext = new SpanContext();\n        let internalTags: any = {};\n        if (!parent || !parent.isValid) {\n            let randomId = Utils.getRandom64();\n            let flags = 0;\n            if (this._sampler.isSampled(operationName, internalTags)) {\n                flags |= constants.SAMPLED_MASK;\n            }\n\n            if (parent) {\n                if (parent.isDebugIDContainerOnly()) {\n                    flags |= (constants.SAMPLED_MASK | constants.DEBUG_MASK);\n                    internalTags[constants.JAEGER_DEBUG_HEADER] = parent.debugId;\n                }\n                // baggage that could have been passed via `jaeger-baggage` header\n                ctx.baggage = parent.baggage;\n            }\n\n            ctx.traceId = randomId;\n            ctx.spanId = randomId;\n            ctx.parentId = null;\n            ctx.flags = flags;\n        } else {\n            ctx.traceId = parent.traceId;\n            ctx.spanId = Utils.getRandom64();\n            ctx.parentId = parent.spanId;\n            ctx.flags = parent.flags;\n\n            // reuse parent's baggage as we'll never change it\n            ctx.baggage = parent.baggage;\n\n            parent.finalizeSampling();\n            ctx.finalizeSampling();\n        }\n\n        return this._startInternalSpan(\n            ctx,\n            operationName,\n            startTime,\n            userTags,\n            internalTags,\n            parent,\n            rpcServer,\n            references\n        );\n    }\n\n    /**\n     * Saves the span context into the carrier object for various formats, and encoders.\n     *\n     * @param  {SpanContext} spanContext - the SpanContext to inject into the\n     *         carrier object. As a convenience, a Span instance may be passed\n     *         in instead (in which case its .context() is used for the\n     *         inject()).\n     * @param  {string} format - the format of the carrier.\n     * @param  {any} carrier - see the documentation for the chosen `format`\n     *         for a description of the carrier object.\n     **/\n    inject(spanContext: SpanContext, format: string, carrier: any): void {\n        if (!spanContext) {\n            return;\n        }\n\n        let injector = this._injectors[format];\n        if (!injector) {\n            throw new Error(`Unsupported format: ${format}`);\n        }\n\n        if (spanContext.context) {\n            spanContext = spanContext.context();\n        }\n\n        spanContext.finalizeSampling();\n        injector.inject(spanContext, carrier);\n    }\n\n    /**\n    * Responsible for extracting a span context from various serialized formats.\n    *\n    * @param  {string} format - the format of the carrier.\n    * @param  {any} carrier - the type of the carrier object is determined by\n    *         the format.\n    * @return {SpanContext}\n    *         The extracted SpanContext, or null if no such SpanContext could\n    *         be found in `carrier`\n    */\n    extract(format: string, carrier: any): SpanContext {\n        let extractor = this._extractors[format];\n        if (!extractor) {\n            throw new Error(`Unsupported format: ${format}`);\n        }\n\n        let spanContext = extractor.extract(carrier);\n\n        if (spanContext) {\n            spanContext.finalizeSampling();\n        }\n        return spanContext;\n    }\n\n    /**\n     * Closes the tracer, flushes spans, and executes any callbacks if necessary.\n     *\n     * @param {Function} [callback] - a callback that runs after the tracer has been closed.\n     **/\n    close(callback: Function): void {\n        let reporter = this._reporter;\n        this._reporter = new NoopReporter();\n        reporter.close(() => {\n            this._sampler.close(callback);\n        });\n    }\n\n    /**\n     * Returns the current timestamp in milliseconds since the Unix epoch.\n     * Fractional values are allowed so that timestamps with sub-millisecond\n     * accuracy can be represented.\n     */\n    now(): number {\n        // TODO investigate process.hrtime; verify it is available in all Node versions.\n        // http://stackoverflow.com/questions/11725691/how-to-get-a-microtime-in-node-js\n        return Date.now();\n    }\n}\n"]}