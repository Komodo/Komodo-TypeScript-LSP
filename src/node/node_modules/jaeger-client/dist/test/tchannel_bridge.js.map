{"version":3,"sources":["../../test/tchannel_bridge.js"],"names":["constants","describe","BIG_TIMEOUT","reporter","tracer","bridge","contextFactory","originalSpan","startSpan","setBaggageItem","ctx1","setSpan","options","as","mode","context","headers","each","o","description","channelEncoding","it","done","server","serviceName","timeout","trace","forceTrace","listen","onServerListening","client","clientSubChannel","makeSubChannel","peers","encodedChannel","channel","entryPoint","join","__dirname","register","tracedHandler","handleServerReq","req","head","body","callback","equal","Object","keys","length","traceIdStr","getSpan","ok","value","err","res","arg2","arg3","tracedChannel","clientCallback","isNotOk","spans","serverSpan","clientSpan","serverSpanTags","Tags","PEER_SERVICE","SPAN_KIND","SPAN_KIND_RPC_SERVER","clientSpanTags","SPAN_KIND_RPC_CLIENT","isOk","hasTags","parentIdStr","spanIdStr","clear","close","request","cn","send"],"mappings":"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","file":"tchannel_bridge.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport _ from 'lodash';\nimport {assert} from 'chai';\nimport * as constants from '../src/constants';\nimport ConstSampler from '../src/samplers/const_sampler';\nimport DefaultContext from '../src/default_context';\nimport path from 'path';\nimport InMemoryReporter from '../src/reporters/in_memory_reporter';\nimport opentracing from 'opentracing';\nimport TestUtils from '../src/test_util.js';\nimport Tracer from '../src/tracer';\nimport TChannel from 'tchannel';\nimport TChannelBridge from '../src/tchannel_bridge.js';\nimport TChannelAsThrift from 'tchannel/as/thrift';\nimport TChannelAsJSON from 'tchannel/as/json';\nimport combinations from './lib/combinations.js'\n\ndescribe ('test tchannel span bridge', () => {\n    // BIG_TIMEOUT is useful for debugging purposes.\n    let BIG_TIMEOUT = 15000000;\n    let reporter = new InMemoryReporter();\n    let tracer = new Tracer(\n        'test-service',\n        reporter,\n        new ConstSampler(true)\n    );\n    let bridge = new TChannelBridge(tracer, {\n        contextFactory: () => { return new DefaultContext(); }\n    });\n    let originalSpan = tracer.startSpan('futurama');\n    originalSpan.setBaggageItem('leela', 'fry');\n    let ctx1 = new DefaultContext();\n    ctx1.setSpan(originalSpan);\n\n    let options = combinations({\n            as: ['json', 'thrift'],\n            mode: ['req.send', 'channel.send'],\n            context: [ctx1, null],\n            headers: [{}, null]\n    });\n\n    _.each(options, (o) => {\n        o.description = `as=${o.as}|mode=${o.mode}`;\n        o.channelEncoding = o.as === 'json' ? TChannelAsJSON: TChannelAsThrift;\n\n        it (o.description + ' spans propagate through tchannel and preserve parent span properties', (done) => {\n            let server = new TChannel({\n                serviceName: 'server',\n                timeout: BIG_TIMEOUT,\n                // force tracing on in order to prove that overriding works\n                trace: true,\n                forceTrace: true\n            });\n            // Server calls client channel after it starts listening.\n            server.listen(4040, '127.0.0.1', onServerListening);\n\n            // Create the top level client channel.\n            let client = new TChannel({\n                // force tracing on in order to prove that overriding works\n                trace: true,\n                forceTrace: true\n            });\n\n            // Create the client subchannel that makes requests.\n            let clientSubChannel = client.makeSubChannel({\n                serviceName: 'server',\n                peers: ['127.0.0.1:4040']\n            });\n\n            // Wrap the subchannel in an encoding\n            let encodedChannel = o.channelEncoding({\n                channel: clientSubChannel,\n                entryPoint: path.join(__dirname, 'thrift', 'echo.thrift') // ignored in json case\n            });\n\n            let options: any = {};\n            encodedChannel.register(server, 'Echo::echo', options, bridge.tracedHandler(handleServerReq));\n            function handleServerReq(context, req, head, body, callback) {\n                // headers should not contain $tracing$ prefixed keys, which should be the\n                // only headers used for this test.\n                assert.equal(Object.keys(head).length, 0);\n\n                // assert that the serverSpan is a child of the original span, if context exists\n                // assert that the serverSpan is NOT a child of the original span, if contexts is null\n                assert.equal(originalSpan.context().traceIdStr === req.context.getSpan().context().traceIdStr, !!o.context);\n                callback(null, { ok: true, body: { value: 'some-string' }});\n            }\n\n            function onServerListening(err, res, arg2, arg3) {\n                // Outgoing tchannel call is traced\n                let tracedChannel = bridge.tracedChannel(encodedChannel);\n\n                let clientCallback = (err, res, headers, body) => {\n                    assert.isNotOk(err);\n                    assert.equal(reporter.spans.length, 2);\n\n                    // the first span to be reported is the server span\n                    let serverSpan = reporter.spans[0];\n                    // the second span to be reported is the client span\n                    let clientSpan = reporter.spans[1];\n\n                    let serverSpanTags = {};\n                    serverSpanTags[opentracing.Tags.PEER_SERVICE] = 'echo';\n                    serverSpanTags[opentracing.Tags.SPAN_KIND] = opentracing.Tags.SPAN_KIND_RPC_SERVER;\n                    serverSpanTags['as'] = o.as;\n                    // TODO(oibe) the port for the client request ephemeral, and I don't know how to get it, or if I can.\n\n                    let clientSpanTags = {};\n                    clientSpanTags[opentracing.Tags.PEER_SERVICE] = 'server';\n                    clientSpanTags[opentracing.Tags.SPAN_KIND] = opentracing.Tags.SPAN_KIND_RPC_CLIENT;\n\n                    assert.isOk(TestUtils.hasTags(serverSpan, serverSpanTags));\n                    assert.isOk(TestUtils.hasTags(clientSpan, clientSpanTags));\n\n                    assert.equal(serverSpan.context().parentIdStr, clientSpan.context().spanIdStr);\n                    // If context exists then the following conditions are true\n                    // else the following conditons are false\n                    assert.equal(serverSpan.context().traceIdStr === originalSpan.context().traceIdStr, !!o.context);\n                    assert.equal(clientSpan.context().traceIdStr === originalSpan.context().traceIdStr, !!o.context);\n\n                    reporter.clear();\n                    server.close();\n                    client.close();\n                    done();\n                }\n\n                if (o.mode === 'req.send') {\n                    let req = tracedChannel.request({\n                        serviceName: 'server',\n                        headers: { cn: 'echo' },\n                        context: o.context,\n                        timeout: BIG_TIMEOUT\n                    });\n                    req.send('Echo::echo', o.headers, { value: 'some-string' }, clientCallback);\n                } else if (o.mode === 'channel.send') {\n                    let req = tracedChannel.channel.request({\n                        serviceName: 'server',\n                        headers: { cn: 'echo' },\n                        context: o.context,\n                        timeout: BIG_TIMEOUT\n                    });\n                    tracedChannel.send(req, 'Echo::echo', o.headers, { value: 'some-string' }, clientCallback);\n                }\n            }\n        }).timeout(BIG_TIMEOUT);\n    });\n});\n"]}