{"version":3,"sources":["../../../src/reporters/udp_sender.js"],"names":["HOST","PORT","UDP_PACKET_MAX_LENGTH","UDPSender","options","_host","host","_port","port","_maxPacketSize","maxPacketSize","_logger","logger","_client","createSocket","on","error","err","_agentThrift","entryPoint","join","__dirname","allowOptionalArguments","allowFilesystemAccess","_jaegerThrift","source","readFileSync","_totalSpanBytes","batch","Agent","emitBatch","argumentsMessageRW","byteLength","_convertBatchToThriftMessage","_batch","length","span","Span","rw","process","_process","tagMessages","j","tags","tag","push","Tag","_thriftProcessMessage","Process","serviceName","_emitSpanBatchOverhead","_calcBatchSize","_maxSpanBytes","spanSize","_calcSpanSize","numSpans","spans","flush","flushResponse","bufferLen","thriftBuffer","Buffer","writeResult","writeInto","send","sent","offset","_reset","spanMessages","i","ArgumentsMessage","version","id","body","Batch","close"],"mappings":"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","file":"udp_sender.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport dgram from 'dgram';\nimport fs from 'fs';\nimport path from 'path';\nimport {Thrift} from 'thriftrw';\nimport NullLogger from '../logger.js';\n\nconst HOST = 'localhost';\nconst PORT =  6832;\nconst UDP_PACKET_MAX_LENGTH = 65000;\n\nexport default class UDPSender {\n    _host: string;\n    _port: number;\n    _maxPacketSize: number;\n    _process: Process;\n    _emitSpanBatchOverhead: number;\n    _logger: Logger;\n    _client: dgram$Socket;\n    _agentThrift: Thrift;\n    _jaegerThrift: Thrift;\n    _batch: Batch;\n    _thriftProcessMessage: any;\n    _maxSpanBytes: number;   // maxPacketSize - (batch + tags overhead)\n    _totalSpanBytes: number; // size of currently batched spans as Thrift bytes\n\n    constructor(options: any = {}) {\n        this._host = options.host || HOST;\n        this._port = options.port || PORT;\n        this._maxPacketSize = options.maxPacketSize || UDP_PACKET_MAX_LENGTH;\n        this._logger = options.logger || new NullLogger();\n        this._client = dgram.createSocket('udp4');\n        this._client.on('error', err => {\n            this._logger.error(`error sending spans over UDP: ${err}`)\n        })\n        this._agentThrift = new Thrift({\n            entryPoint: path.join(__dirname, '../thriftrw-idl/agent.thrift'),\n            allowOptionalArguments: true,\n            allowFilesystemAccess: true\n        });\n        this._jaegerThrift = new Thrift({\n            source: fs.readFileSync(path.join(__dirname, '../jaeger-idl/thrift/jaeger.thrift'), 'ascii'),\n            allowOptionalArguments: true\n        });\n        this._totalSpanBytes = 0;\n    }\n\n    _calcBatchSize(batch: Batch) {\n        return this._agentThrift.Agent.emitBatch.argumentsMessageRW.byteLength(\n            this._convertBatchToThriftMessage(this._batch)\n        ).length;\n    }\n\n    _calcSpanSize(span: any): number {\n        return this._jaegerThrift.Span.rw.byteLength(new this._jaegerThrift.Span(span)).length;\n    }\n\n    setProcess(process: Process): void {\n        // This function is only called once during reporter construction, and thus will\n        // give us the length of the batch before any spans have been added to the span\n        // list in batch.\n        this._process = process;\n        this._batch = {\n            'process': this._process,\n            'spans': []\n        };\n\n        let tagMessages = [];\n        for (let j = 0; j < this._batch.process.tags.length; j++) {\n            let tag = this._batch.process.tags[j];\n            tagMessages.push(new this._jaegerThrift.Tag(tag));\n        }\n\n        this._thriftProcessMessage = new this._jaegerThrift.Process({\n            serviceName: this._batch.process.serviceName,\n            tags: tagMessages\n        });\n        this._emitSpanBatchOverhead = this._calcBatchSize(this._batch);\n        this._maxSpanBytes = this._maxPacketSize - this._emitSpanBatchOverhead;\n    }\n\n    append(span: any): SenderResponse {\n        let spanSize: number = this._calcSpanSize(span);\n        if (spanSize > this._maxSpanBytes) {\n            return { err: true, numSpans: 1 };\n        }\n\n        if (this._totalSpanBytes + spanSize <= this._maxSpanBytes) {\n            this._batch.spans.push(span);\n            this._totalSpanBytes += spanSize;\n            if (this._totalSpanBytes < this._maxSpanBytes) {\n                // still have space in the buffer, don't flush it yet\n                return {err: false, numSpans: 0};\n            }\n            return this.flush();\n        }\n\n        let flushResponse: SenderResponse = this.flush();\n        this._batch.spans.push(span);\n        this._totalSpanBytes = spanSize;\n        return flushResponse;\n    }\n\n    flush(): SenderResponse {\n        let numSpans: number = this._batch.spans.length;\n        if (numSpans == 0) {\n            return {err: false, numSpans: 0}\n        }\n\n        let bufferLen = this._totalSpanBytes + this._emitSpanBatchOverhead;\n        let thriftBuffer = new Buffer(bufferLen);\n        let writeResult = this._agentThrift.Agent.emitBatch.argumentsMessageRW.writeInto(\n            this._convertBatchToThriftMessage(this._batch), thriftBuffer, 0\n        );\n\n        if (writeResult.err) {\n            this._logger.error(`error writing Thrift object: ${writeResult.err}`);\n            return {err: true, numSpans: numSpans};\n        }\n\n        // Having the error callback here does not prevent uncaught exception from being thrown,\n        // that's why in the constructor we also add a general on('error') handler.\n        this._client.send(thriftBuffer, 0, thriftBuffer.length, this._port, this._host, (err, sent) => {\n            if (err) {\n                this._logger.error(`error sending spans over UDP: ${err}, packet size: ${writeResult.offset}, bytes sent: ${sent}`);\n            }\n        });\n        this._reset();\n\n        return {err: false, numSpans: numSpans};\n    }\n\n    _convertBatchToThriftMessage() {\n        let spanMessages = [];\n        for (let i = 0; i < this._batch.spans.length; i++) {\n            let span = this._batch.spans[i];\n            spanMessages.push(new this._jaegerThrift.Span(span))\n        }\n\n        return new this._agentThrift.Agent.emitBatch.ArgumentsMessage({\n            version: 1,\n            id: 0,\n            body: {batch: new this._jaegerThrift.Batch({\n                    process: this._thriftProcessMessage,\n                    spans: spanMessages\n            })}\n        });\n    }\n\n    _reset() {\n        this._batch.spans = [];\n        this._totalSpanBytes = 0;\n    }\n\n    close(): void {\n        this._client.close();\n    }\n}\n"]}